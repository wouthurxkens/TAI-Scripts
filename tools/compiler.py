import struct
import os
import ti_tokens

class Compiler:
    def __init__(self):
        pass

    def _sum_bytes(self, data):
        """Sum bytes for checksum."""
        return sum(data)

    def _do_checksum(self, total_sum):
        """Return the lower 16 bits of the sum."""
        return total_sum & 0xFFFF

    def compile(self, in_file, out_file):
        """Reads text and compiles to binary .8xp."""
        try:
            with open(in_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
        except IOError:
            print("Error: Couldn't open input file.")
            return False

        output = bytearray()
        
        for line in lines:
            line = line.rstrip('\n')
            if not line:
                continue
                
            while line:
                # Grab the longest possible token
                s = line[:ti_tokens.LONGEST_INPUT]
                valid_token = None
                
                while s and not valid_token:
                    valid_token = ti_tokens.lookup_token_by_str(s)
                    if not valid_token:
                        s = s[:-1]
                
                # Special case for alphabet characters
                if not s and line[0].isalpha():
                    token_val = ord(line[0].upper())
                    valid_token = {'token': token_val, 'sz': 1}
                    s = line[0]
                    
                if not s:
                    print(f"Error: Invalid token found near '{line}'.")
                    return False
                else:
                    # Write token. sz=1 -> pack B, sz=2 -> pack <H (little-endian)
                    if valid_token['sz'] == 1:
                        output.extend(struct.pack('B', valid_token['token']))
                    else:
                        output.extend(struct.pack('<H', valid_token['token']))
                        
                    line = line[len(s):]
            
            # Output a newline
            newline_token = ti_tokens.lookup_token_by_str('\n')
            if newline_token:
                output.extend(struct.pack('B', newline_token['token']))

        output_size = len(output)
        if output_size > 0xFFFF:
            print("Error: program is too large")
            return False

        # Build ProgramHeader (55 bytes)
        datalen = 17 + output_size + 2 # sizeof(VariableEntry) + size + sizeof(size)
        header = struct.pack('<8s3s42sH', 
                             b'**TI83F*', 
                             b'\x1A\x0A\x00', 
                             b'Generated by the TI-BASIC Compiler.'.ljust(42, b'\x00'), 
                             datalen)

        # Build VariableEntry (17 bytes)
        # Get filename without extension, capped at 8 chars
        base_name = os.path.splitext(os.path.basename(out_file))[0].upper()[:8].encode('ascii')
        base_name = base_name.ljust(8, b'\x00')
        length1_2 = output_size + 2
        
        ventry = struct.pack('<HHB8sBBH', 0x0D, length1_2, 0x05, base_name, 0, 0, length1_2)

        # Write output file
        try:
            with open(out_file, 'wb') as f:
                f.write(header)
                f.write(ventry)
                
                size_bytes = struct.pack('<H', output_size)
                f.write(size_bytes)
                f.write(output)
                
                # Checksum calculation: sum of ventry, size bytes, and data bytes
                total_sum = self._sum_bytes(ventry) + self._sum_bytes(size_bytes) + self._sum_bytes(output)
                checksum = self._do_checksum(total_sum)
                f.write(struct.pack('<H', checksum))
        except IOError:
            print("Error: Couldn't write to output file.")
            return False
            
        return True

    def decompile(self, in_file, out_file):
        """Reads binary .8xp and decompiles to text."""
        try:
            with open(in_file, 'rb') as f:
                header = f.read(55) # ProgramHeader
                ventry = f.read(17) # VariableEntry
                
                length_bytes = f.read(2)
                if not length_bytes: return False
                token_length = struct.unpack('<H', length_bytes)[0]
                
                n_bytes_read = 0
                s_output = ""
                b_asm = False
                
                while n_bytes_read < token_length:
                    # Try to read 2 bytes, but fallback to 1 if at EOF
                    temp_bytes = f.read(2)
                    if not temp_bytes: break
                    
                    if len(temp_bytes) == 1:
                        val = temp_bytes[0]
                        f.seek(-1, os.SEEK_CUR) # Equivalent to C++ fseek fallback
                        bytes_consumed = 1
                    else:
                        val = struct.unpack('<H', temp_bytes)[0]
                        bytes_consumed = 2

                    if b_asm:
                        if (val & 0xFF) == 0x3F:
                            s_output += "\n"
                        s_output += chr(val & 0xFF)
                        f.seek(-1, os.SEEK_CUR)
                        n_bytes_read += 1
                        continue
                        
                    # Lookup token
                    conv = ti_tokens.lookup_token_by_val(val)
                    if not conv:
                        conv = ti_tokens.lookup_token_by_val(val & 0xFF)
                        
                    if not conv:
                        s_output += chr(val & 0xFF)
                        f.seek(-1, os.SEEK_CUR)
                        n_bytes_read += 1
                    else:
                        s_output += conv
                        token_info = ti_tokens.lookup_token_by_str(conv)
                        
                        if token_info['sz'] < 2:
                            f.seek(-1, os.SEEK_CUR)
                            n_bytes_read += 1
                        else:
                            n_bytes_read += 2
                            
                        if conv == "AsmPrgm":
                            b_asm = not b_asm
                            
        except IOError:
            print("Error: Couldn't open input file.")
            return False

        try:
            with open(out_file, 'w', encoding='utf-8') as f:
                f.write(s_output)
        except IOError:
            print("Error: Couldn't write to output file.")
            return False
            
        return True